---
description: 
globs: apps/api/**/*
alwaysApply: false
---
# API Engineering Standards (apps/api)

## Database & Schema Management

### Database Schema Organization
- All database schemas must be placed in `packages/db-schema/src/` with appropriate subdirectories (`core/`, `auth/`, etc.)
- Schema files must export table definitions and be properly imported in `core/defs.ts`
- Always generate migrations using `pnpm db:gen-migrations` after schema changes which will automatically create the sql migration files
- Repository classes must be placed in `apps/api/src/database/repositories/` and follow the naming pattern `*-repository.ts`
- Use the established repository pattern with dependency injection into manager services
- Include proper indexes for foreign keys and frequently queried columns

### Database Computation Patterns
- **SQL-First Philosophy**: Always prefer database aggregations over in-memory processing
  - Use SQL `SUM()`, `AVG()`, `COUNT()` instead of fetching all rows and calculating in JavaScript
  - Use `DISTINCT ON` with proper indexes for latest-record queries
  - Use database-level `GROUP BY` for grouping operations
  - Use CTEs (Common Table Expressions) for complex multi-step queries
  - Example: Getting latest summaries should use `DISTINCT ON (agent_id)` not fetch all and filter in memory
- **Composite Indexes**: Always add indexes for:
  - Foreign key relationships
  - Columns used in `WHERE` clauses
  - Columns used in `ORDER BY` with `DISTINCT ON`
  - Multi-column patterns that match query patterns (e.g., `(agent_id, competition_id, timestamp DESC)`)
- **Query Optimization Principles**:
  - Avoid N+1 queries - use joins or batch fetching
  - Use database cursors for large result sets
  - Leverage database window functions for ranking and analytics
  - Use `EXPLAIN ANALYZE` to verify query performance

### Migration Best Practices
- **Migration Generation**: Always use `pnpm --filter api db:gen-migrations` after schema changes
- **Migration Naming**: Let Drizzle auto-generate names (e.g., `0041_mighty_wolverine.sql`)
- **Migration Review**: Always review generated SQL before committing
- **Backward Compatibility**: Migrations must be backward compatible for zero-downtime deployments
- **Data Migrations**: Use separate scripts in `apps/api/scripts/` for data migrations, never mix schema and data migrations
- **Rollback Strategy**: Document rollback SQL for destructive changes in PR description
- **Testing Migrations**: Test migrations on a copy of production data when possible
- **Index Creation**: Create indexes `CONCURRENTLY` in production to avoid table locks

### Database Type Safety
- **JSON Fields**: Never use `any` for jsonb columns
  - Create type guard functions for runtime validation
  - Use Zod schemas for complex JSON structures
  - Example: `isValidPerpsConfig(data): data is PerpsConfig`
- **Numeric Types**: Always parse database numerics to numbers
  - Use `Number()` or `parseFloat()` for numeric columns
  - Never pass numeric strings to frontend
  - Be explicit about precision requirements
- **Enum Safety**: Use TypeScript enums or literal unions for database enums
- **Null Handling**: Explicitly handle nullable columns with proper types
  - Use `| null` not `| undefined` for nullable database fields
  - Consider using Result types for operations that may fail

## Authentication & Security

### Authentication Patterns
- Agent authentication uses API keys via `Authorization: Bearer` header
- User authentication uses session-based auth with SIWE (Sign-In With Ethereum)
- Never mix authentication patterns - each endpoint should use one consistent method
- All wallet verification must use nonce-based verification

### Security Operations
- Threat modeling required for new authentication flows
- Audit trails required for critical business operations
- Rate limiting required for all public endpoints
- Circuit breaker patterns for external service dependencies

## Testing Standards

### E2E Test Organization
- All E2E tests must be in `apps/api/e2e/tests/` directory
- Test helpers must be in `apps/api/e2e/utils/` directory
- Always reference and re-use existing test setup helpers (where applicable) - for example, in `apps/api/e2e/utils/test-helpers.ts`
- When implementing a new test, always first look at existing test patterns in other test files - for example, `apps/api/e2e/tests/user.test.ts` for examples that use the user authentication flow, and `apps/api/e2e/tests/agent.test.ts` that use the agent authentication flow

### Test Environment Requirements
- Whenever in doubt about how tests in the e2e testing suite are set up, always reference `apps/api/e2e/setup.ts`, `apps/api/e2e/utils/test-setup.ts`, `apps/api/e2e/run-tests.ts`, and `apps/api/vitest.config.ts` to ensure you have a complete understanding of the environment

### Testing Coverage Requirements
- All new manager service methods must have corresponding tests
- Wallet verification functionality must be tested with both success and failure scenarios
- Database operations should be tested with edge cases (duplicates, constraints)
- Authentication flows must be thoroughly tested
- Performance-critical changes require load testing validation

### Test Coverage Standards
- **Current Global Thresholds** (from `coverage.config.json`):
  - Lines: 4%
  - Statements: 4%
  - Functions: 46%
  - Branches: 46%
  - Note: Coverage is calculated across all packages in aggregate
- **Package-Specific Thresholds**:
  - `apps/api`: 0% all metrics (testing infrastructure in development)
  - `apps/comps`: 0% all metrics (frontend testing not yet implemented)
  - `packages/rewards`: 100% all metrics (strictly enforced)
  - `packages/staking-contracts`: 100% all metrics (strictly enforced)
- **Coverage Migration Strategy**:
  - New packages must start with 100% coverage requirements
  - Existing apps (api, comps) will gradually increase thresholds
  - Any new critical path code must have tests regardless of package thresholds
- **Critical Path Coverage**: 100% coverage required for:
  - Authentication flows
  - Payment/trading operations
  - Wallet verification
  - Competition scoring logic
  - Financial calculations (PnL, portfolio values)
- **Coverage Reporting**: All PRs must include coverage report via GitHub Actions
- **Test Data Management**: 
  - Never use production data in tests
  - Use factories or builders for test data generation
  - Maintain test data consistency across test suites
- **Test Quality Metrics**:
  - Tests should be deterministic (no flaky tests)
  - Tests should run in isolation
  - Tests should complete within reasonable time (< 30s for unit, < 2min for E2E)

### Running Tests
- To run tests using the e2e testing suite, you can use a format such as `cd apps/api && pnpm test:e2e name-of-test.test.ts`

## API Design Patterns

### Response Format Consistency
- All API responses must include `success: boolean` field
- Error responses must include `error: string` and `status: number` fields
- Use consistent HTTP status codes (400 for validation, 401 for auth, 409 for conflicts)
- Success responses should include relevant data fields and descriptive `message` when appropriate
- **Error Response Format**:
  ```typescript
  {
    success: false,
    error: string,
    status: number,
    details?: object, // Only in development
    requestId?: string
  }
  ```
- **Success Response Format**:
  ```typescript
  {
    success: true,
    data: T,
    message?: string,
    pagination?: {
      total: number,
      limit: number,
      offset: number,
      hasMore: boolean
    }
  }
  ```

### Route Organization
- Group routes by feature in `apps/api/src/routes/` (e.g., `agent.routes.ts`, `auth.routes.ts`)
- Use middleware for authentication consistently across related endpoints
- Keep route handlers thin - business logic belongs in manager services
- Use TypeScript types for request/response validation

### API Evolution & Compatibility
- Breaking changes DO NOT require version increments and deprecation notices
- Schema evolution must support gradual migration patterns
- Client SDK updates coordinated with API changes

## Service Layer Architecture

### Controller Patterns
- Controller functions should be focused primarily on serialization/deserialization of requests and responses
- Controllers should avoid any complex business logic, instead calling into specialized manager classes in the service layer to handle business logic.
- Controller functions should never call into the Repository layer directly.

### Manager Service Patterns
- Business logic must be in manager services (`apps/api/src/services/*-manager.service.ts`)
- Manager services should inject repository dependencies in constructor
- Use dependency injection pattern established in `AppContext`
- Keep manager methods focused on single responsibilities
- Always handle errors gracefully and return consistent result objects

### Service Method Design Patterns
- **Method Complexity:** If a service method has 3+ distinct steps (especially if labeled as "Step 1", "Step 2", etc.), consider extracting each step into a private helper method
- **Retry Logic Separation:** Extract retry logic with exponential backoff into dedicated helper methods rather than inline in business logic
- **Batch Operation Helpers:** Create reusable helpers for batch operations (batch fetching, batch processing) that can be shared across methods
- **Clear Method Contracts:** Helper methods should clearly indicate what they assume about their inputs:
  - Use descriptive names like `processWithValidatedData` vs just `processData`
  - Document preconditions in method comments
  - Consider using TypeScript branded types or type predicates for validated data
- **Fail-Fast in Service Methods:** 
  - Validate inputs and check preconditions at the start of public methods
  - Return early on invalid conditions rather than nesting the entire method body
  - Let helper methods assume valid inputs (since the public method already validated)

### Code Reuse & Method Implementation
- **Before implementing any new method**: Always search the codebase for similar existing functionality using semantic search or grep
- **If a similar method exists but is not adequate**: You must explicitly explain why the existing method cannot be used or extended, including:
  - What specific requirements the existing method doesn't meet
  - Why extending/modifying the existing method isn't feasible
  - Technical justification for creating a new method instead
- **Staff-Level Engineering Approach**: When working on any code in `apps/api`, approach all design decisions and trade-off analysis as a staff backend engineer at a FAANG company would. This means:
  - Evaluating all viable implementation options holistically
  - Considering long-term maintainability, scalability, and team velocity
  - Following industry best practices while making context-appropriate decisions
  - Ensuring the chosen solution is the best fit for the specific situation at hand
- **Document relationships**: If creating a new method that's similar to an existing one, document the relationship and differences in TSDoc comments

### Configuration Management
- Use `apps/api/src/config/index.ts` for centralized configuration
- Environment variables should be loaded once at startup, not per-request
- Validate required environment variables on application startup
- Use configuration objects rather than direct `process.env` access in business logic

## Performance & Scalability

### Performance Requirements
- API endpoints must respond within 200ms for 95th percentile
- Critical business operations (wallet verification, trades) must emit metrics
- Caching strategy required for frequently accessed data (user sessions, price data)
- Retry logic with exponential backoff for transient failures
- Capacity planning and scaling thresholds must be documented
- **Query Optimization**:
  - Use `LIMIT` and `OFFSET` for all list endpoints
  - Default page size: 10-50 items (never unlimited)
  - Use database cursors for large result sets
  - Avoid N+1 queries - use joins or batch fetching
  - Maximum query time: 1000ms before timeout
- **Caching Strategy**:
  - LRU cache for frequently accessed data
  - Cache TTL: 60s for prices, 300s for competition data
  - Cache invalidation on mutations
  - Use Redis for distributed caching
  - Cache warming for critical data on startup
- **Response Time SLAs**:
  - P95 < 200ms for reads
  - P95 < 500ms for writes
  - P95 < 1000ms for complex aggregations
  - P99 < 2000ms for all endpoints
- **Rate Limiting**:
  - Default: 100 requests per minute per API key
  - Burst: Allow 20% over limit for 10 seconds
  - Return `429 Too Many Requests` with `Retry-After` header

### Monitoring & Observability
- All API endpoints must include structured logging with request IDs
- Health check endpoints must validate all dependencies (DB, external APIs)
- Business metric tracking and performance SLIs/SLOs required
- **Metrics Collection**:
  - Response times per endpoint
  - Database query performance
  - Cache hit rates
  - Business metrics (trades/hour, active agents, competition participation)
  - Error rates by type and endpoint
- **Logging Standards**:
  - Structured JSON logging
  - Request ID propagation through all layers
  - Log levels: ERROR, WARN, INFO, DEBUG
  - Separate application and error logs
  - Never log sensitive data (passwords, API keys, PII)
- **Health Checks**:
  - `/health` - Basic liveness check
  - `/health/ready` - Readiness check including:
    - Database connectivity
    - Redis connectivity
    - External service availability
    - Disk space and memory usage
- **Alert Thresholds**:
  - Error rate > 1% for 5 minutes
  - P95 response time > 500ms for 10 minutes
  - Database connection pool > 80% utilized
  - Memory usage > 85%

## Code Quality & Documentation

### Documentation Requirements
- All public manager service methods must have TSDoc comments
- Include `@param` and `@returns` documentation
- Document error conditions and side effects
- Repository methods should document database operations and constraints
- At the end of implementing a new feature, always check to see if this invalidates content in `apps/api/README.md` that must be updated
- For any new environment variables, ensure that `apps/api/.env.example`, `apps/api/.env.test`, and `.github/workflows/api-ci.yml` has been updated to include it
