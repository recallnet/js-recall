# Project Overview

This project is a TypeScript monorepo for Recall, built using Turborepo and pnpm workspaces. It contains both shared packages and applications that work together to provide Recall's functionality.

The GitHub repo for this project is: https://github.com/recallnet/js-recall

## Coding pattern preferences

– Always prefer simple solutions
– Avoid duplication of code whenever possible, which means checking for other areas of the codebase that might already have similar code and functionality
– Write code that takes into account the different environments: dev, test, and prod
– You are careful to only make changes that are requested or you are confident are well understood and related to the change being requested
– When fixing an issue or bug, do not introduce a new pattern or technology without first exhausting options for the existing implementation. And if you finally do this, make sure to remove the old implementation afterwards so we don't have duplicate logic.
– Keep the codebase very clean and organized
– Avoid writing scripts if possible, especially if the script is likely only to be run once
– Avoid having files over 200–300 lines of code. Refactor at that point.
– Mocking data is only needed for tests, never mock data for dev or prod
– Never add stubbing or fake data patterns to code that affects the dev or prod environments
- When using command-line tools, don't try to run them in interactive mode if they may hang waiting for input.
- Maintain excellent inline documentation for any code you contribute.
- Always thoroughly use inline documentation for all functions, methods, types, etc.

# Agent Context Folder

The `.agent/` directory is used for maintaining development context and task tracking:

## Specifications
- Create `spec.md` for new features or major changes
- Ensure specs align with GitHub issues
- Get developer approval on specs before proceeding
- Include acceptance criteria and requirements

## Development Plans
- Create `developer_plan.md` for implementation tracking
- Break down tasks into clear, measurable phases
- Include links to relevant documentation and examples
- Track completion status for each task
- Document dependencies and prerequisites
- Split complex plans into multiple PRs if needed

## Task Management
- Use checkboxes to track completed items
- Document blockers and dependencies
- Keep notes on additional work discovered
- Track progress against acceptance criteria

## Quality Gates
Before marking a phase complete, verify:
- All lint checks pass
- Prettier formatting is correct
- Documentation is complete
- Build succeeds
- Development environment runs
If editing the README, please conform to the [standard-readme](https://github.com/RichardLitt/standard-readme) specification.

## Development Tracking
- Ensure all secrets or passwords are ketp out of tracked code. Never commit files such as .env.
- Execute a `git add . && git commit -m "<description of the change>"` after each change you make.

# Repository Structure

## Apps (`apps/*`)
- `portal/`: Main web application for Recall
- `faucet/`: Faucet application

## Packages (`packages/*`)
Core Libraries:
- `sdk/` (@recallnet/sdk): Core SDK implementation
- `sdkx/` (@recallnet/sdkx): Core SDK implementation
- `ui/` (@recallnet/ui): Shared UI component library
- `contracts/` (@recallnet/contracts): Smart contract interfaces
- `chains/` (@recallnet/chains): Chain-specific configurations
- `address-utils/` (@recallnet/address-utils), `bigint-utils/` (@recallnet/bigint-utils): Utility libraries
- `fvm/` (@recallnet/fvm): FVM-specific functionality
- `network-constants/` (@recallnet/network-constants v0.0.6): Network configuration constants
- `fonts/` (@recallnet/fonts): Shared font resources

Development Tools:
- `eslint-config/` (@recallnet/eslint-config): Shared ESLint configuration
- `typescript-config/` (@recallnet/typescript-config): Shared TypeScript configuration

# Development Guidelines

## Build and Test Requirements
Every time you complete a task, ensure:
1. Lint passes: `pnpm lint`
2. Prettier check passes: `pnpm format:check`
3. (only if the pnpm docs:check script exists) Dev environment runs: `pnpm docs:check`
4. Build succeeds: `pnpm build`
5. Dev environment runs: `pnpm dev`

## Monorepo Rules
- Each package/app must be able to build and run independently
- Changes to shared packages must not break dependent apps
- Use workspace dependencies with `workspace:*` version
- Follow the Turborepo pipeline defined in `turbo.json`

## Code Quality Standards
- Use TypeScript for all new code
- Follow ESLint rules from `@recallnet/eslint-config`
- Maintain consistent formatting with Prettier
- Keep packages focused and minimal
- Document exports and complex functions
- Write tests for critical functionality
- Maintain comprehensive TSDoc documentation:
  - All public APIs must have TSDoc comments
  - All functions must have parameter and return type documentation
  - All types, interfaces, and classes must be documented
  - Complex algorithms must include detailed explanations
  - Examples should be provided for non-obvious usage
  - Documentation coverage must be at least 99%
  - (only if the pnpm docs:check or pnpm docs:build script exists) Run `pnpm docs:check` to verify documentation coverage
  - (only if the pnpm docs:check or pnpm docs:build script exists) Run `pnpm docs:build` to generate documentation

## Package Development
- Keep packages small and focused
- Export types for all public APIs
- Version packages using changesets
- Document breaking changes
- Maintain backward compatibility when possible

## Application Development
- Use Next.js for web applications
- Follow the app directory structure
- Implement responsive designs
- Handle errors gracefully
- Use proper loading states
- Optimize for performance

## Component Guidelines
- Use the shared UI library when possible
- Follow accessibility best practices
- Implement proper error boundaries
- Use TypeScript strictly
- Document props and usage
- Keep components pure when possible

## State Management
- Use React hooks for local state
- Implement proper loading states
- Handle errors gracefully
- Cache network requests appropriately
- Use proper TypeScript types

## Testing Requirements
- Write unit tests for utilities
- Test components in isolation
- Implement integration tests
- Test error scenarios
- Verify accessibility

## Performance Guidelines
- Optimize bundle sizes
- Implement code splitting
- Use proper caching strategies
- Monitor performance metrics
- Optimize images and assets

## Environment and Tools
- Node.js >= 20
- pnpm 9.12.3 or higher
- Use VSCode with recommended extensions
- Configure editor for ESLint and Prettier

# Important Scripts
- `pnpm build`: Build all packages and apps
- `pnpm dev`: Run development environment
- `pnpm lint`: Run ESLint checks
- `pnpm format`: Format code with Prettier
- `pnpm clean`: Clean build artifacts
- `pnpm changeset`: Manage package versions
- `pnpm version-packages`: Update package versions
- `pnpm publish-packages`: Publish to registry
- `pnpm docs:check`: Verify TSDoc coverage meets 99% threshold
- `pnpm docs:build`: Generate TypeDoc documentation for all packages

# Documentation Requirements
- Maintain README files
- Document API changes
- Update usage examples
- Include setup instructions
- Document environment variables

# Deployment Guidelines
- Verify all tests pass
- Check bundle sizes
- Review dependency updates
- Test in staging environment
- Monitor performance metrics

# Additional Resources
- [Turborepo Documentation](https://turbo.build/repo/docs)
- [pnpm Workspace Guide](https://pnpm.io/workspaces)
- [Next.js Documentation](https://nextjs.org/docs)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [React Documentation](https://react.dev/)

# AI Interaction Guidelines
- Use TypeScript for all generated code
- Follow existing patterns and conventions
- Maintain consistent error handling
- Document complex algorithms
- Test generated code thoroughly
- Consider performance implications
- Use existing utilities and components
- Follow the monorepo structure
- Respect package boundaries
- Consider dependency implications